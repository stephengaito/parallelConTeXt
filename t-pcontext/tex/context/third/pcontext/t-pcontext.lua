
-- This is the lua code associated with t-pcontext.mkxl file

local tInsert    = table.insert
local tRemove    = table.remove
local tSerialize = table.serialize
local pprint     = require('pprint')

thirddata            = thirddata            or { }
thirddata.pcontext   = thirddata.pcontext   or { }

local pcontext       = thirddata.pcontext

pcontext.subDocs     = pcontext.subDocs     or { }
local subDocs        = pcontext.subDocs

pcontext.subDocOrder = pcontext.subDocOrder or { }
local subDocOrder    = pcontext.subDocOrder

local function initializer()
  print("HELLO FROM PConTeXt initializer!")
end

local function finalizer()
  print("GOOD BYE FROM PConTeXt initializer!")
end

job.register(
  'thirddata.pcontext.subDocs',
  'thirddata.pcontext.subDocs',
  initializer, finalizer
)

-- Consider using `job.loadother` and using tables.accesstable to retrieve 
-- the required data from the returned utilitydata. The problem with this 
-- approach is that the *.tuc file will be loaded an other time.

-- local utilitydata = job.loadother(tex.jobname..'.tuc')
-- local subDocs = 
--   tables.accesstable('utilitydata.pcontext.subDocs', utilitydata)

-- Actually we do not need the job.load....

-- Flow of data:

-- 1. On each context run we collect a sequence of required commands for a 
-- given subDocument. This is saved by the registered `job.save` (and 
-- ignored by any subsequent `job.load`). 

-- 2. The resulting sequence is then taken from the indvidual *.tuc files 
-- and harmonized by the compile script and saved into the (master) plua 
-- file. 

-- 3. When pcontext loads the (master) plua file and walks through the 
-- sequence. 

local environments = { }

local function pushEnvironment(envName)
  tInsert(environments, envName)
end

-- currently unused...
local function popEnvironment()
  tRemove(environments)
end

pcontext.pushEnvironment = pushEnvironment

local currentSectionBlock = { }

local function startSectionBlock(blockName, blockOptions)
--  print("startSectionBlock: ", blockName, " options: [", blockOptions, "]")
  tInsert(currentSectionBlock, blockName)
  tInsert(currentSectionBlock, blockOptions)
end

pcontext.startSectionBlock = startSectionBlock

local function stopSectionBlock(blockName)
  currentSectionBlock = { }
end

pcontext.stopSectionBlock = stopSectionBlock

local currentDocument = { }

local function startDocument(docName, docOptions)
  print("startDocument", docName, docOptions)
  tInsert(currentDocument, docName)
  tInsert(currentDocument, docOptions)
end

pcontext.startDocument = startDocument

local function stopDocument(docName)
  currentDocument = { }
end

pcontext.stopDocument = stopDocument

local function insertStartOptions(theSubDoc, curCmdArray)
  if 0 < #curCmdArray then
    cmdOptions = ""
    if 1 < #curCmdArray and 0 < #curCmdArray[2] then
      cmdOptions = "["..curCmdArray[2].."]"
    end
    tInsert(theSubDoc, "\\start"..curCmdArray[1]..cmdOptions)
  end
end

local function insertStopOptions(theSubDoc, curCmdArray)
  if 0 < #curCmdArray then
    tInsert(theSubDoc, "\\stop"..curCmdArray[1])
  end
end

local function buildSubDocument(subDocumentName)
  theSubDoc = { }
  for i, anEnv in ipairs(environments) do
    tInsert(theSubDoc, "\\environment " .. anEnv)
  end
  insertStartOptions(theSubDoc, currentDocument)
  insertStartOptions(theSubDoc, currentSectionBlock)
  tInsert(theSubDoc, "\\component " .. subDocumentName)
  insertStopOptions(theSubDoc, currentSectionBlock)
  insertStopOptions(theSubDoc, currentDocument)
  local i = 0
  local subDocInstanceName = subDocumentName..'-'..i
  while subDocs[subDocInstanceName] do
    i = i + 1
    subDocInstanceName = subDocumentName..'-'..i
  end
  subDocs[subDocInstanceName] = {
    ["firstPage"] = 0,
    ["numPages"]  = 0,
    ["document"]  = theSubDoc
  }
  tInsert(subDocOrder, subDocInstanceName)
end

pcontext.buildSubDocument = buildSubDocument

luatex.registerstopactions(function()

  -- only (re)create the *.plua file IF we are in `extract` mode
  if tex.modes["extract"] then
    pcontext.jobname = tex.jobname
    local jobname    = pcontext.jobname

    local randomseedStr = tostring(job.variables.tobesaved.randomseed)
    
    for n, v in pairs(subDocs) do
      local f = io.open(n.."-parallel.tex", 'w')
      if f then
        f:write("%% This is the Parallel ConTeXt Document for "..n.."\n")
        f:write("%% this file has been autogenerated -- do not edit\n\n")
        for i, l in ipairs(v["document"]) do
          f:write(l.."\n")
        end
        f:write("\n")
        f:close()
      end
    end

    local f = io.open(tex.jobname..'.plua', 'w')
    if f then
      f:write("-- This is the plua data file for the Parallel ConTeXt build of "..jobname.."\n")
      f:write("-- This file has been autogenerated -- do not edit\n\n")
    
      f:write("local pcontext       = { }\n\n")

      f:write("pcontext.jobname=\""..jobname.."\"\n\n")
      
      f:write("pcontext.lastRun=0\n\n")
    
      f:write("pcontext.randomseed="..randomseedStr.."\n\n")
      
      f:write(tSerialize(subDocOrder, "pcontext.subDocOrder", true), "\n\n")
    
      f:write(tSerialize(subDocs, "pcontext.subDocs", true), "\n\n")
    
      f:write("return pcontext")
      f:close()
    end
  end
end)


----------------------------------------------------------------------

local function startpcontext()

end

pcontext.startpcontext = startpcontext

local function stoppcontext()

end

pcontext.stoppcontext = stoppcontext
